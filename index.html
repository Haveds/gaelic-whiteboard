<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaelic Football Tactical Whiteboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 10px;
            gap: 10px;
        }

        .panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .side-panel {
            width: 200px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .side-panel h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }

        .roster {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .player-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin-bottom: 5px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 12px;
        }

        .player-item.red {
            border-left: 3px solid #ff4444;
        }

        .player-item.blue {
            border-left: 3px solid #3EA846;
        }

        .player-name {
            font-weight: bold;
            flex: 1;
        }

        .player-buttons {
            display: flex;
            gap: 3px;
        }

        .btn-small {
            padding: 3px 6px;
            font-size: 10px;
            cursor: pointer;
            border: none;
            border-radius: 3px;
            background: #666;
            color: white;
        }

        .btn-small:hover {
            background: #444;
        }

        .panel-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn {
            padding: 10px;
            font-size: 12px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            font-weight: bold;
        }

        .btn:hover {
            background: #45a049;
        }

        .btn-secondary {
            background: #2196F3;
        }

        .btn-secondary:hover {
            background: #0b7dda;
        }

        .btn-warning {
            background: #ff9800;
        }

        .btn-warning:hover {
            background: #e68900;
        }

        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-wrap: wrap;
        }

        .toolbar label {
            font-weight: bold;
            font-size: 14px;
        }

        .toolbar input[type="radio"] {
            margin-right: 5px;
        }

        .toolbar select {
            padding: 5px 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            background: white;
        }

        .toolbar select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .mode-option {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .color-separator {
            height: 30px;
            width: 2px;
            background: #ddd;
            margin: 0 5px;
        }

        .canvas-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            overflow: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }

        #pitch {
            display: block;
            cursor: crosshair;
        }

        #pitch.select-mode {
            cursor: default;
        }

        .info-text {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            padding: 5px;
            background: #f9f9f9;
            border-radius: 3px;
        }

        @media (max-width: 1200px) {
            .side-panel {
                width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel - Team Red -->
        <div class="panel side-panel">
            <h2>Team Red Roster</h2>
            <div class="roster" id="red-roster"></div>
            <div class="panel-buttons">
                <button class="btn" onclick="addPlayer('red')">Add Player</button>
                <button class="btn btn-secondary" onclick="saveTeamPositions('red')">Save Positions</button>
                <button class="btn btn-warning" onclick="resetTeamPositions('red')">Reset to Saved</button>
            </div>
            <div class="info-text">
                Click "Save Positions" to save current formation. "Reset to Saved" shows movement arrows.
            </div>
        </div>

        <!-- Center Panel - Canvas -->
        <div class="center-panel">
            <div class="toolbar">
                <label>Mode:</label>
                <label class="mode-option">
                    <input type="radio" name="mode" value="select" checked onchange="changeMode()">
                    Select/Move
                </label>
                
                <div class="color-separator"></div>
                
                <label>Draw Lines:</label>
                <label class="mode-option">
                    <input type="checkbox" id="lineDrawingToggle" onchange="toggleLineDrawing()">
                    Enabled
                </label>
                
                <div class="color-separator"></div>
                
                <label>Line Color:</label>
                <select id="lineColor">
                    <option value="#000000">Black</option>
                    <option value="#ffffff">White</option>
                    <option value="#ffff00" selected>Yellow</option>
                    <option value="#ff4444">Red</option>
                    <option value="#4444ff">Blue</option>
                    <option value="#8b4513">Brown</option>
                    <option value="#ff69b4">Pink</option>
                </select>
                
                <button class="btn btn-warning" onclick="clearAllLines()" style="margin-left: auto;">Clear All Lines</button>
                <button class="btn btn-secondary" onclick="clearLastLine()">Clear Last Line</button>
                <button class="btn" onclick="saveConfiguration()">ðŸ’¾ Save</button>
                <button class="btn" onclick="document.getElementById('loadFile').click()">ðŸ“‚ Load</button>
                <input type="file" id="loadFile" accept=".json" style="display:none" onchange="loadConfiguration(event)">
            </div>
            <div class="canvas-container">
                <canvas id="pitch"></canvas>
            </div>
        </div>

        <!-- Right Panel - Team Blue -->
        <div class="panel side-panel">
            <h2>Team Blue Roster</h2>
            <div class="roster" id="blue-roster"></div>
            <div class="panel-buttons">
                <button class="btn" onclick="addPlayer('blue')">Add Player</button>
                <button class="btn btn-secondary" onclick="saveTeamPositions('blue')">Save Positions</button>
                <button class="btn btn-warning" onclick="resetTeamPositions('blue')">Reset to Saved</button>
            </div>
            <div class="info-text">
                Click "Save Positions" to save current formation. "Reset to Saved" shows movement arrows.
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const PITCH_LENGTH = 140; // meters (vertical)
        const PITCH_WIDTH = 85;   // meters (horizontal)
        const SCALE = 4;          // pixels per meter
        const CANVAS_WIDTH = PITCH_WIDTH * SCALE;
        const CANVAS_HEIGHT = PITCH_LENGTH * SCALE;
        const PLAYER_RADIUS = 15;

        // State
        let mode = 'select';
        let players = {
            red: [],
            blue: []
        };
        let selectedPlayer = null;
        let isDragging = false;
        let isDrawing = false;
        let currentLine = [];
        let lines = [];
        
        // Zoom and pan state
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        
        // Line drawing mode
        let lineDrawingEnabled = false;
        
        // Shadow tokens (one per player)
        let shadows = new Map(); // playerKey -> {x, y, name, color}

        // Canvas setup
        const canvas = document.getElementById('pitch');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Player class
        class Player {
            constructor(x, y, name, color, team) {
                this.x = x;
                this.y = y;
                this.name = name;
                this.color = color;
                this.team = team;
                this.savedX = x;
                this.savedY = y;
            }

            draw() {
                // Draw circle
                ctx.beginPath();
                ctx.arc(this.x, this.y, PLAYER_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw name with dynamic sizing
                const displayName = this.name.substring(0, 6).toUpperCase();
                const nameLength = displayName.length;
                let fontSize;
                if (nameLength <= 3) fontSize = 9;
                else if (nameLength === 4) fontSize = 8;
                else if (nameLength === 5) fontSize = 7;
                else fontSize = 6;

                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(displayName, this.x, this.y);
            }
            
            drawShadow() {
                // Draw semi-transparent shadow circle
                ctx.beginPath();
                ctx.arc(this.x, this.y, PLAYER_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = this.color + '40'; // Add transparency
                ctx.fill();
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw name with dynamic sizing
                const displayName = this.name.substring(0, 6).toUpperCase();
                const nameLength = displayName.length;
                let fontSize;
                if (nameLength <= 3) fontSize = 9;
                else if (nameLength === 4) fontSize = 8;
                else if (nameLength === 5) fontSize = 7;
                else fontSize = 6;

                ctx.fillStyle = '#888888';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(displayName, this.x, this.y);
            }

            containsPoint(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) <= PLAYER_RADIUS;
            }

            savePosition() {
                this.savedX = this.x;
                this.savedY = this.y;
            }
        }

        // Line class
        class Line {
            constructor(points, color, curved = false) {
                this.points = points;
                this.color = color;
                this.curved = curved;
            }

            draw() {
                if (this.points.length < 4) return;

                // Draw the line
                ctx.save(); // Save current context state
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(this.points[0], this.points[1]);

                if (this.curved) {
                    // Draw all points for curved lines
                    for (let i = 2; i < this.points.length; i += 2) {
                        ctx.lineTo(this.points[i], this.points[i + 1]);
                    }
                } else {
                    // Draw straight line to the end point
                    const endX = this.points[this.points.length - 2];
                    const endY = this.points[this.points.length - 1];
                    ctx.lineTo(endX, endY);
                }

                ctx.stroke();
                ctx.restore(); // Restore context state

                // Draw arrowhead
                if (this.points.length >= 4) {
                    const len = this.points.length;
                    let x1, y1, x2, y2;
                    
                    if (len === 4) {
                        x1 = this.points[0];
                        y1 = this.points[1];
                        x2 = this.points[2];
                        y2 = this.points[3];
                    } else {
                        x1 = this.points[len - 4];
                        y1 = this.points[len - 3];
                        x2 = this.points[len - 2];
                        y2 = this.points[len - 1];
                    }

                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const arrowLength = 15;
                    const arrowAngle = Math.PI / 6;

                    ctx.beginPath();
                    ctx.moveTo(x2, y2);
                    ctx.lineTo(
                        x2 - arrowLength * Math.cos(angle - arrowAngle),
                        y2 - arrowLength * Math.sin(angle - arrowAngle)
                    );
                    ctx.lineTo(
                        x2 - arrowLength * Math.cos(angle + arrowAngle),
                        y2 - arrowLength * Math.sin(angle + arrowAngle)
                    );
                    ctx.closePath();
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }
        }

        // Draw pitch
        function drawPitch() {
            ctx.fillStyle = '#656b60';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Lines at 13m, 21m, 45m, 65m from each end
            ctx.lineWidth = 2;
            [13, 21, 45, 65].forEach(dist => {
                // From top
                let y = dist * SCALE;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
                ctx.stroke();

                // From bottom
                y = (PITCH_LENGTH - dist) * SCALE;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
                ctx.stroke();
            });

            // Center line (10m wide)
            const centerY = PITCH_LENGTH / 2 * SCALE;
            const lineWidth = 10 * SCALE;
            ctx.strokeRect(0, centerY - lineWidth / 2, CANVAS_WIDTH, lineWidth);

            // Goals
            const goalWidth = 20 * SCALE;
            const goalX = (PITCH_WIDTH / 2 - 10) * SCALE;
            
            ctx.strokeStyle = 'yellow';
            // Top goal
            ctx.strokeRect(goalX, 0, goalWidth, 5 * SCALE);
            // Bottom goal
            ctx.strokeRect(goalX, CANVAS_HEIGHT - 5 * SCALE, goalWidth, 5 * SCALE);
        }

        // Initialize teams
        function initializeTeams() {
            // Team Red (top side)
            const redPositions = [
                [42.5, 10],     // GK
                [25, 25], [70, 25],           // Full-Backs
                [25, 40], [47, 40], [70, 40],           // Half-Backs
                [35, 70], [60, 70],                       // Midfield
                [25, 100], [47, 100], [70, 100],        // Half-Forwards
                [25, 115], [70, 115],        // Full-Forwards
            ];
            
            const redNames = ["GK", "LFB", "RFB", "LHB", "CHB", "RHB", 
                             "LM", "RM", "LHF", "CHF", "RHF", "LFF", "RFF"];
            
            redPositions.forEach(([x, y], i) => {
                players.red.push(new Player(x * SCALE, y * SCALE, redNames[i], '#ff4444', 'red'));
            });

            // Team Blue (bottom side)
            const bluePositions = [
                [42.5, 130],    // GK
                [65, 115], [20, 115],        // Full-Backs
                [65, 100], [42.5, 115], [20, 100],        // Half-Backs
                [55, 70], [30, 70],                       // Midfield
                [65, 40], [42.5, 45], [20, 40],           // Half-Forwards
                [65, 25], [20, 25],           // Full-Forwards
            ];
            
            const blueNames = ["BEEZ", "RFB", "LFB", "RHB", "CHB", "LHB",
                              "RM", "LM", "RHF", "CHF", "LHF", "RFF", "LFF"];
            
            bluePositions.forEach(([x, y], i) => {
                players.blue.push(new Player(x * SCALE, y * SCALE, blueNames[i], '#3EA846', 'blue'));
            });

            updateRosterDisplays();
        }

        // Update roster displays
        function updateRosterDisplays() {
            ['red', 'blue'].forEach(team => {
                const roster = document.getElementById(`${team}-roster`);
                roster.innerHTML = '';
                
                players[team].forEach((player, index) => {
                    const div = document.createElement('div');
                    div.className = `player-item ${team}`;
                    div.innerHTML = `
                        <span class="player-name">${player.name}</span>
                        <div class="player-buttons">
                            <button class="btn-small" onclick="editPlayer('${team}', ${index})">Edit</button>
                            <button class="btn-small" onclick="removePlayer('${team}', ${index})">Del</button>
                        </div>
                    `;
                    roster.appendChild(div);
                });
            });
        }

        // Add player
        function addPlayer(team) {
            if (players[team].length >= 30) {
                alert('Maximum 30 players per team');
                return;
            }

            const name = prompt('Enter player name:');
            if (name) {
                const color = team === 'red' ? '#ff4444' : '#3EA846';
                const x = (10 + players[team].length * 5) * SCALE;
                const y = team === 'red' ? 10 * SCALE : (PITCH_LENGTH - 10) * SCALE;
                
                players[team].push(new Player(x, y, name, color, team));
                updateRosterDisplays();
                render();
            }
        }

        // Edit player
        function editPlayer(team, index) {
            const player = players[team][index];
            const newName = prompt('Enter new name:', player.name);
            if (newName) {
                player.name = newName;
                updateRosterDisplays();
                render();
            }
        }

        // Remove player
        function removePlayer(team, index) {
            if (confirm(`Remove ${players[team][index].name}?`)) {
                players[team].splice(index, 1);
                updateRosterDisplays();
                render();
            }
        }

        // Save team positions
        function saveTeamPositions(team) {
            players[team].forEach(player => player.savePosition());
            alert(`Team ${team} positions saved`);
        }

        // Reset team positions
        function resetTeamPositions(team) {
            const color = team === 'red' ? '#ff4444' : '#3EA846';
            
            players[team].forEach(player => {
                if (player.x !== player.savedX || player.y !== player.savedY) {
                    lines.push(new Line([player.x, player.y, player.savedX, player.savedY], color, false));
                    player.x = player.savedX;
                    player.y = player.savedY;
                }
            });
            
            render();
        }

        // Change mode
        function changeMode() {
            mode = document.querySelector('input[name="mode"]:checked').value;
            canvas.className = mode === 'select' ? 'select-mode' : '';
            selectedPlayer = null;
            isDragging = false;
            isDrawing = false;
            currentLine = [];
        }
        
        // Toggle line drawing
        function toggleLineDrawing() {
            lineDrawingEnabled = document.getElementById('lineDrawingToggle').checked;
        }
        
        // Save configuration to JSON file
        function saveConfiguration() {
            const config = {
                players: {
                    red: players.red.map(p => ({
                        x: p.x, y: p.y, name: p.name, 
                        savedX: p.savedX, savedY: p.savedY
                    })),
                    blue: players.blue.map(p => ({
                        x: p.x, y: p.y, name: p.name,
                        savedX: p.savedX, savedY: p.savedY
                    }))
                },
                lines: lines.map(l => ({
                    points: l.points,
                    color: l.color,
                    curved: l.curved
                })),
                shadows: Array.from(shadows.entries()).map(([key, shadow]) => ({
                    key: key,
                    shadow: shadow
                }))
            };
            
            const json = JSON.stringify(config, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gaelic-formation-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Load configuration from JSON file
        function loadConfiguration(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    
                    // Clear existing data
                    players.red = [];
                    players.blue = [];
                    lines = [];
                    shadows.clear();
                    
                    // Load players
                    ['red', 'blue'].forEach(team => {
                        const color = team === 'red' ? '#ff4444' : '#3EA846';
                        config.players[team].forEach(p => {
                            const player = new Player(p.x, p.y, p.name, color, team);
                            player.savedX = p.savedX;
                            player.savedY = p.savedY;
                            players[team].push(player);
                        });
                    });
                    
                    // Load lines
                    config.lines.forEach(l => {
                        lines.push(new Line(l.points, l.color, l.curved));
                    });
                    
                    // Load shadows
                    if (config.shadows) {
                        config.shadows.forEach(({key, shadow}) => {
                            shadows.set(key, shadow);
                        });
                    }
                    
                    updateRosterDisplays();
                    render();
                    alert('Configuration loaded successfully!');
                } catch (err) {
                    alert('Error loading file: ' + err.message);
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // Apply zoom transform
        function applyTransform() {
            ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
        }
        
        // Convert screen coordinates to canvas coordinates (accounting for zoom/pan)
        function screenToCanvas(screenX, screenY) {
            return {
                x: (screenX - offsetX) / scale,
                y: (screenY - offsetY) / scale
            };
        }

        // Clear lines
        function clearAllLines() {
            lines = [];
            shadows.clear();
            render();
        }

        function clearLastLine() {
            if (lines.length > 0) {
                lines.pop();
                render();
            }
        }

        // Get canvas coordinates
        function getCanvasCoords(event) {
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            return screenToCanvas(screenX, screenY);
        }
        
        // Get player key for shadow tracking
        function getPlayerKey(player) {
            return `${player.team}-${player.name}`;
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            const coords = getCanvasCoords(e);
            
            // Middle mouse or ctrl+click for panning
            if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
                isPanning = true;
                const rect = canvas.getBoundingClientRect();
                panStartX = e.clientX - rect.left - offsetX;
                panStartY = e.clientY - rect.top - offsetY;
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
                return;
            }
            
            if (mode === 'select') {
                const allPlayers = [...players.red, ...players.blue];
                for (const player of allPlayers) {
                    if (player.containsPoint(coords.x, coords.y)) {
                        selectedPlayer = player;
                        isDragging = true;
                        
                        // If line drawing is enabled, record start position
                        if (lineDrawingEnabled) {
                            const key = getPlayerKey(player);
                            const existingShadow = shadows.get(key);
                            
                            // If there's already a shadow, this is a continuation
                            // Remove old shadow, create new one at current position
                            if (existingShadow) {
                                // Shadow stays at original position, will be updated
                            } else {
                                // First move - create shadow at current position
                                shadows.set(key, {
                                    x: player.x,
                                    y: player.y,
                                    name: player.name,
                                    color: player.color
                                });
                            }
                            
                            // Start a new line from current position
                            currentLine = [player.x, player.y];
                        }
                        return;
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            // Handle panning
            if (isPanning) {
                const rect = canvas.getBoundingClientRect();
                offsetX = e.clientX - rect.left - panStartX;
                offsetY = e.clientY - rect.top - panStartY;
                render();
                return;
            }
            
            const coords = getCanvasCoords(e);
            
            if (mode === 'select' && isDragging && selectedPlayer) {
                selectedPlayer.x = coords.x;
                selectedPlayer.y = coords.y;
                
                // If line drawing is enabled, add to current line
                if (lineDrawingEnabled && currentLine.length >= 2) {
                    currentLine.push(coords.x, coords.y);
                }
                
                render();
                
                // Draw preview line if line drawing is enabled
                if (lineDrawingEnabled && currentLine.length >= 4) {
                    const previewColor = document.getElementById('lineColor').value;
                    ctx.save();
                    applyTransform();
                    ctx.strokeStyle = previewColor;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(currentLine[0], currentLine[1]);
                    for (let i = 2; i < currentLine.length; i += 2) {
                        ctx.lineTo(currentLine[i], currentLine[i + 1]);
                    }
                    ctx.stroke();
                    ctx.restore();
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = mode === 'select' ? 'default' : 'crosshair';
                return;
            }
            
            const coords = getCanvasCoords(e);
            
            if (mode === 'select') {
                if (isDragging && selectedPlayer) {
                    // Finalize line if line drawing was enabled
                    if (lineDrawingEnabled && currentLine.length >= 4) {
                        const color = document.getElementById('lineColor').value;
                        
                        // Update the shadow position to where the drag started
                        const key = getPlayerKey(selectedPlayer);
                        const shadow = shadows.get(key);
                        if (shadow) {
                            // Shadow should be at the start of the line
                            shadow.x = currentLine[0];
                            shadow.y = currentLine[1];
                        }
                        
                        // Add the final position to the line
                        currentLine[currentLine.length - 2] = selectedPlayer.x;
                        currentLine[currentLine.length - 1] = selectedPlayer.y;
                        
                        // Create the line (always treated as curved for smooth paths)
                        lines.push(new Line([...currentLine], color, true));
                        currentLine = [];
                    }
                }
                
                isDragging = false;
                selectedPlayer = null;
            }
        });
        
        // Mouse wheel for zooming
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Get mouse position in canvas coordinates before zoom
            const beforeX = (mouseX - offsetX) / scale;
            const beforeY = (mouseY - offsetY) / scale;
            
            // Adjust zoom
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            const newScale = Math.min(Math.max(0.5, scale * zoomFactor), 5);
            
            // Calculate new offset to keep mouse position steady
            const afterX = beforeX * newScale;
            const afterY = beforeY * newScale;
            
            offsetX = mouseX - afterX;
            offsetY = mouseY - afterY;
            scale = newScale;
            
            render();
        });

        // Render everything
        function render() {
            // Clear and reset transform
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply zoom and pan
            applyTransform();
            
            // Draw pitch
            drawPitch();
            
            // Draw lines
            lines.forEach(line => line.draw());
            
            // Draw shadow tokens
            shadows.forEach(shadow => {
                const tempPlayer = new Player(shadow.x, shadow.y, shadow.name, shadow.color, '');
                tempPlayer.drawShadow();
            });
            
            // Draw players
            [...players.red, ...players.blue].forEach(player => player.draw());
        }

        // Initialize
        initializeTeams();
        render();
    </script>
</body>
</html>
